#计算机组成原理课程设计——36条流水线CPU

[TOC]

##一. 个人信息

<u>学号：072110112</u>

<u>姓名：冉中益</u>

<u>班号：1621102</u>

<u>专业：计算机科学与技术</u>

## 二. 模块定义及代码实现

###1. 数据通路

####datapath_PPL

##### 基本描述

统合所有流水段，流水段寄存器以及各个冒险处理模块，从而形成完整的流水线数据通路

##### 模块接口

| 接口名 | 方向 |   描述   |
| :----: | :--: | :------: |
|  clk   |  I   | 时钟信号 |
|  rst   |  I   | 复位信号 |

##### 功能

1. 取下一条执行指令
2. 根据控制信号对不同流水段的指令进行执行和操作
3. 包含冒险处理模块 对各种冒险进行处理

##### 代码实现

```verilog
`include"PC_PPL.v"
`include"IUnit.v"
`include"IF_ID.v"
`include"ID.v"
`include"ID_EX.v"
`include"EX.v"
`include"EX_Mem.v"
`include"Mem.v"
`include"Mem_Wr.v"
`include"Wr.v"
`include"Pre_Data_Hazard.v"
`include"branch_Data_Hazard.v"
`include"MULT_Data_Hazard.v"
`include"CPR_Data_Hazard.v"
`include"ERET_Data_Hazard.v"
`include"Load_use.v"

module datapath_PPL(clk,rst);

	input	clk,rst;
	
	wire[31:2]	PC,NPC;
	wire[31:2]	IF_PC,ID_PC,EX_PC,Mem_PC,Wr_PC;
	wire[31:0]	instruction,ID_instruction,pre_instruction;
	wire		sign,signal;
	wire[31:0]	E,F;
	wire	ID_Jump,EX_Jump;
	wire	ID_Branch,EX_Branch;
	wire[5:0]	ID_op,EX_op,Mem_op,Wr_op;
	wire[4:0]	ID_rs,EX_rs,Mem_rs,Wr_rs;
	wire[4:0]	ID_rt,EX_rt,Mem_rt,Wr_rt;	
	wire[4:0]	ID_rd,EX_rd,Mem_rd,Wr_rd;
	wire[4:0]	ID_shamt,EX_shamt,Mem_shamt,Wr_shamt;
	wire[5:0]	ID_func,EX_func,Mem_func,Wr_func;
	wire[15:0]	ID_imm16,EX_imm16;
	wire[25:0]	ID_target,EX_target;
	wire[31:0]	ID_busA,EX_busA,Mem_busA,Wr_busA;
	wire[31:0]	ID_busB,EX_busB,Mem_busB,Wr_busB;
	wire		ID_RegDst,EX_RegDst,Mem_RegDst,Wr_RegDst;
	wire	ID_RegWr,EX_RegWr,Mem_RegWr,Wr_RegWr;
	wire	ID_ALUSrc,EX_ALUSrc;
	wire	ID_MemWr,EX_MemWr,Mem_MemWr;
	wire	ID_MemtoReg,EX_MemtoReg,Mem_MemtoReg,Wr_MemtoReg;
	wire[1:0]	ID_ExtOp,EX_ExtOp;
	wire[4:0]	ID_ALUctr,EX_ALUctr;
	wire[31:0]	alure,Mem_alure,Wr_alure;
	wire[4:0]	EX_Reg,Mem_Reg,Wr_Reg;
	wire[31:0]	Mem_dout,Wr_dout;
	wire[31:0]	Wr_busW;
	//wire[1:0]	ALUSrcA,ALUSrcB;
	wire[31:0]	A,B;
	wire[1:0]	ALUSrcC,ALUSrcD;
	wire[1:0]	ALUSrcE,ALUSrcF;
	wire		Load_use;
	wire		EX_MemRead;
	//wire[31:0]	ID_hi_num;
	wire[31:0]	EX_hi_num;
	//wire[31:0]	ID_lo_num;
	wire[31:0]	EX_lo_num;
	wire[63:0]	EX_MULT_result,Mem_MULT_result,Wr_MULT_result;
	wire[2:0]	ALUSrcG,ALUSrcH;
	wire[31:0]	G,H;
	wire[1:0]	ALUSrcK,ALUSrcL;
	wire[31:0]	K;
	wire[31:0]	EX_cs_num;

	PC_PPL PCP(NPC,rst,clk,PC,
Load_use);
	IUnit IPP(PC,IF_PC,instruction);
	IF_ID IFIDPP(IF_PC,instruction,ID_PC,ID_instruction,ID_Jump,ID_Branch,ID_op,ID_func,clk,
pre_instruction,sign,signal,
Load_use);

	ID IDPP(ID_PC,ID_op,ID_rs,ID_rt,ID_rd,ID_shamt,ID_func,ID_imm16,ID_target,ID_busA,ID_busB,ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,
ID_Branch,ID_Jump,ID_ExtOp,ID_ALUctr,ID_instruction,NPC,
Wr_op,Wr_PC,Wr_alure,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_busW,Wr_RegWr,Wr_RegDst,
alure,Mem_alure,Mem_dout,Mem_MemtoReg,
ALUSrcC,ALUSrcD,
PC,
sign,
pre_instruction,E,F,
ALUSrcE,ALUSrcF,
Wr_MULT_result,Wr_busA,Wr_busB,
G,H,EX_MULT_result,EX_busA,Mem_MULT_result,Mem_busA,
ALUSrcG,ALUSrcH,ALUSrcK,ALUSrcL,
A,B,K,
EX_busB,Mem_busB,
clk,rst);

	ID_EX IDEXPP(ID_PC,ID_op,ID_rs,ID_rt,ID_rd,ID_shamt,ID_func,ID_imm16,ID_target,ID_busA,ID_busB,ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,ID_Branch,ID_Jump,ID_ExtOp,ID_ALUctr,
G,H,K,
clk,
EX_PC,EX_op,EX_rs,EX_rt,EX_rd,EX_shamt,EX_func,EX_imm16,EX_target,EX_busA,EX_busB,EX_RegDst,EX_RegWr,EX_ALUSrc,EX_MemWr,EX_MemtoReg,EX_Branch,EX_Jump,EX_ExtOp,EX_ALUctr,
EX_hi_num,EX_lo_num,EX_cs_num,
Load_use,
signal,pre_instruction,E,F,
A,B);


	EX EXPP(EX_PC,EX_op,EX_rs,EX_rt,EX_rd,EX_shamt,EX_func,EX_imm16,EX_target,EX_busA,EX_busB,
EX_RegDst,EX_RegWr,EX_ALUSrc,EX_MemWr,EX_MemtoReg,EX_Branch,EX_Jump,EX_ExtOp,EX_ALUctr,
alure,EX_Reg,clk,
Mem_alure,Wr_busW,
EX_MemRead,
EX_MULT_result,
EX_hi_num,EX_lo_num,
EX_cs_num);

	EX_Mem EXMEMPP(EX_op,EX_Reg,EX_RegWr,EX_MemWr,EX_MemtoReg,EX_PC,EX_rs,EX_rt,EX_rd,EX_shamt,EX_func,EX_RegDst,EX_busA,EX_busB,alure,clk,
Mem_op,Mem_Reg,Mem_RegWr,Mem_MemWr,Mem_MemtoReg,Mem_alure,Mem_PC,Mem_rs,Mem_rt,Mem_rd,Mem_shamt,Mem_func,Mem_RegDst,Mem_busA,Mem_busB,
EX_MULT_result,Mem_MULT_result);

	Mem MEMPP(Mem_op,Mem_Reg,Mem_busB,Mem_RegWr,Mem_MemWr,Mem_MemtoReg,Mem_alure,clk,Mem_dout);

	Mem_Wr MEMWRPP(Mem_op,Mem_Reg,Mem_RegWr,Mem_MemtoReg,Mem_alure,Mem_dout,Mem_PC,Mem_rs,Mem_rt,Mem_rd,Mem_shamt,Mem_func,Mem_RegDst,Mem_busA,Mem_busB,clk,
Wr_op,Wr_Reg,Wr_RegWr,Wr_MemtoReg,Wr_alure,Wr_dout,Wr_PC,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_RegDst,Wr_busA,Wr_busB,
Mem_MULT_result,Wr_MULT_result);

	Wr WRPP(Wr_op,Wr_Reg,Wr_RegWr,Wr_MemtoReg,Wr_alure,Wr_dout,Wr_PC,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_RegDst,Wr_busA,Wr_busB,clk,Wr_busW);

	Pre_Data_Hazard PDHPP(Mem_RegWr,Mem_Reg,ID_rs,ID_rt,EX_RegWr,EX_Reg,Wr_RegWr,Wr_Reg,ALUSrcC,ALUSrcD);

	branch_Data_Hazard BDHPP(Wr_RegWr,Wr_Reg,pre_instruction[25:21],pre_instruction[20:16],Mem_RegWr,Mem_Reg,ALUSrcE,ALUSrcF);

	MULT_Data_Hazard MDHPP(ID_op,ID_func,EX_op,EX_func,Mem_op,Mem_func,Wr_op,Wr_func,ALUSrcG,ALUSrcH);

	CPR_Data_Hazard CDHPP(ID_op,EX_op,Mem_op,Wr_op,ID_rs,EX_rs,Mem_rs,Wr_rs,ID_rd,EX_rd,Mem_rd,Wr_rd,ALUSrcK);

	ERET_Data_Hazard EDHPP(ID_op,ID_func,EX_op,Mem_op,Wr_op,EX_rs,Mem_rs,Wr_rs,EX_rd,Mem_rd,Wr_rd,ALUSrcL);

	Load_use LUPP(EX_MemRead,EX_rt,ID_rs,ID_rt,Load_use);

endmodule
```

#####（附）36条流水线数据通路图

![image-20230701094221071](/Users/plotnickslope/Library/Application Support/typora-user-images/image-20230701094221071.png)

> 这张图是一开始设计45条流水线时进行绘制的 包括在后续的代码编写中也加入了45条的一些处理模块 ==但由于最终时间不够 没有完成额外9条指令的调试 所以在下面的介绍中不会介绍45条相对于36条的额外模块 由于将额外模块删去较为复杂 所以在提交的代码文件中仍有额外的模块！==这些模块包括`CPR_Data_Hazard, CPRFIle, ERET_Data_Hazard, MULT_Data_Hazard, MULT, MULTFile `另外 在各个模块中都涉及到了额外9条指令的部分 ==这些部分均不作解释==

***数据通路分析：***

*指令相关*

1. **PC模块**： 计算取指令的地址。复位信号为1时，PC的值赋为13(PC末尾两位省略)。在没有出现Load_use冒险的情况下，时钟下降沿到来时PC赋值为NPC，否则保持不变。
2. **NPC模块**： 计算下一个PC，同时计算对分支指令是否跳转标记为sign。主要根据OP信号进行NPC计算方法的区分。
3. **im模块**： 用于取对应`code.txt`文件中的指令。

*寄存器相关*

1. **RegFile模块**： 寄存器的取数与存数。寄存器的大体框架与36条指令单周期CPU没有区别，多加了两个取数的地址参数。因为一条指令在寄存器中取数与存数的操作处于不同阶段，虽然RegFile置于ID模块，但实际使用时，Wr模块的操作也会在此进行，即写入操作。
2. **dm模块**：在数据内存中读数以及取数。同时需要考虑sb指令，其写入方法较为特殊。

*冒险处理*

1. **Pre_Data_Hazard模块**：处理从寄存器中读数存在的延迟问题。在ID段进行检测，处理在EX段，Mem段，Wr段可能出现的寄存器数据修改问题。取到的寄存器数应为最近一次修改的值。最后输出ALUSrcC和ALUSrcD进行冒险记录并输出。
2. **Branch_Data_Hazard模块**：处理pre_instruction从寄存器中读数存在的延迟问题。在ID段进行检测可能出现的寄存器数据修改问题。取到的寄存器数应为最近一次修改的值。最后输出ALUSrcE和ALUSrcF进行冒险记录并输出。
3. **Load_use模块**：首先检测是否遇到Load_use冒险，若遇到则置Load_use信号为1。

*段寄存器模块*

1. **IF_ID模块**：把IF段的数据传输到ID段。在出现syscall指令和ERET指令的情况下，将ID_instruction赋为0，若没有Load_use冒险并且不为分支跳转指令，ID_PC赋值为IF_PC，ID_instruction赋值为instruction；若没有Load_use冒险但为分支或跳转指令，则ID_PC保持不变；若出现Load_use冒险，则不进行任何操作。
2. **ID_EX模块**：把ID段的数据传输到EX段。若出现Load_use冒险，则EX段信号全部赋值为0；若出现分支指令不跳转，则赋值为保存的分支指令的下一条指令(即pre_instruction)的相关数值；其他情况下皆把EX段数值赋值为ID段数值。
3. **EX_Mem模块**：把EX段的数据传输到Mem段。
4. **Mem_Wr模块**：把Mem段的数据传输到Wr段。

*运算模块*

**alu模块**：输入端口为：ALUctr, busA, busB与exout选择后的结果data2，exout，instruction[10:6]，输出端口为alure,zero；

以上模块较为重要，在此详细说明。综合以上模块，根据对应控制信号进行操作。因R,I,J类型的指令都存在这样的情况：同种类型的指令之间存在路径不同的现象，所以按类型指令给出总体路径不具备很好的代表性，若要综述同一类型的指令之间的路径，要所有同一类型的指令都满足，则R,I,J三种类型的综述路径几乎一致，因而此处不给出类型指令数据通路演示。

#### alu

##### 基本描述

根据不同的译码结果，对传入的数据信号进行不同操作的基本运算，并输出运算结果

#####模块接口

| 接口名  | 方向 |     描述     |
| :-----: | :--: | :----------: |
| ALUctr  |  I   |   操作信号   |
|    A    |  I   |    输入A     |
|    B    |  I   |    输入B     |
| immedia |  I   | 扩展后立即数 |
|  shamt  |  I   |    移位数    |
| result  |  O   | ALU运算结果  |
|  zero   |  O   |   0标志位    |

##### 功能

根据不同的操作码进行不同的基本运算

##### 代码实现

各操作码对应的运算类型已经在代码中通过注释方式明确给出 此处不再附上操作码与运算类型的对应关系表

```verilog
module alu(ALUctr,A,B,immedia,shamt,result,zero,G,H,K);
	input[4:0]	ALUctr;
	input[31:0]	A,B,G,H,K;
	input[31:0]	immedia;
	input[4:0]	shamt;
	output[31:0]	result;
	output		zero;

	reg[31:0]	result;
	assign		zero = (result == 32'b0);
	integer		i;

	always @(*)
		begin
			case(ALUctr)
				5'b00000:result <= A + B;//addu
				5'b00001:result <= A - B;//subu
				5'b00010://slt
					begin
						if(A[31] ^ B[31])	result <= (A[31]==1)?1:0;
						else	result <= (A<B)?1:0;
					end
				5'b00011:result <= A & B;//and
				5'b00100:result <= ~(A | B);//nor
				5'b00101:result <= A | B;//or
				5'b00110:result <= A ^ B;//xor
				5'b00111:result <= B << shamt;//sll
				5'b01000:result <= B >> shamt;//srl
				5'b01001:result <= (A<B)?1:0;//sltu
				//5'b01010:jalr
				//5'b01011:jr
				5'b01100:result <= B << A;//sllv
				5'b01101:result <= $signed(B) >>> shamt;//sra 
				5'b01110:result <= $signed(B) >>> A;//srav
				5'b01111:result <= B >> A;//srlv
				5'b10000:result <= A + immedia;//addiu sign extension
				5'b10001://slti sign extension
					begin
						if(A[31] ^ immedia[31])	result <= (A[31]==1)?1:0;	
						else	result <= (A<immedia)?1:0;
					end
				5'b10010:result <= (A<immedia)?1:0;//sltiu,sign extension
				5'b10011:result <= A & immedia;//andi
				5'b10100:result <= A | immedia;//ori
				5'b10101:result <= A ^ immedia;//xori
				5'b10110:result <= immedia;//lui
				5'b10111:result <= G;//mflo
				5'b11000:result <= H;//mfhi
				5'b11001:result <= K;//mfc0
			endcase
		end
endmodule
```

#### dm_4k

#####基本描述

数据存储器 对数据进行写入存储和读出

##### 模块接口

| 接口名 | 方向 |            描述             |
| :----: | :--: | :-------------------------: |
|   op   |  I   | 指令操作码 用于sb指令的判断 |
|  addr  |  I   |           地址码            |
|  din   |  I   |          数据输入           |
|  dout  |  O   |          数据输出           |
|  clk   |  I   |          时钟信号           |
|   we   |  I   |         写使能信号          |

##### 功能

1. `we`信号为1时将`din`中的数据写入`dm`中
2. 将`addr`地址码指定的数据赋给`dout` 连接输出到其他模块中

##### 代码实现

```verilog
module dm_4k(op, addr, din, dout, clk, we);

input[5:0]	op;
input[31:0]	addr;
input[31:0]	din;
input		clk;
input		we;
output[31:0]	dout;

reg[7:0] dm[4095:0]; //采取以字节位单位存储数据才是最合理的

integer i;

always @(negedge clk)
begin
if(we)
begin
    if(op == 6'b101000)   //sb
        dm[addr] <= din[7:0];
    else {dm[addr + 3], dm[addr + 2], dm[addr + 1], dm[addr]} <= din;
end
end

assign dout = {dm[addr + 3], dm[addr + 2], dm[addr + 1], dm[addr]};

endmodule
```

#### extender

##### 基本描述

位扩展器 根据传入的控制信号进行不同类型的扩展操作

##### 模块接口

| 接口名  | 方向 |      描述      |
| :-----: | :--: | :------------: |
| immedia |  I   |   输入立即数   |
|  exop   |  I   | 扩展指令操作码 |
|  exout  |  O   |    扩展输出    |

##### 功能

根据指令码`exop`对立即数进行0扩展、符号扩展或低位0扩展（用于lui指令）

`exop`与操作的关系可见代码

##### 代码实现

```verilog
module extender(immedia,exop,exout);
	input[15:0]	immedia;
	input[1:0]	exop;
	output[31:0]	exout;
	reg[31:0]	exout;

	always@(*)
		if(exop == 2'b00)
			exout <= {16'b0,immedia};//zero extender
		else if(exop == 2'b01)
			exout <= {{16{immedia[15]}},immedia};//sign extender
		else if(exop == 2'b10)
			exout <= {immedia,16'b0};//lui extender
endmodule
```

#### im_4k

##### 基本描述

从`code.txt`中读取并存储指令，每一周期根据地址返回响应指令

##### 模块接口

| 接口名 | 方向 |   描述   |
| :----: | :--: | :------: |
|  addr  |  I   | 指令地址 |
|  dout  |  O   | 指令输出 |

##### 功能

1. 初始化时从`code.txt`中读取指令 并将其按序存储在`im`指令存储器中
2. 每一周期根据传入的addr读取指令，通过`dout`接口连接到其他模块输入中

##### 代码实现

```verilog
module im_4k(addr,dout);
	input[11:2]	addr;
	output[31:0]	dout;

	reg[31:0]	im[1023:0];
	integer		i;
	initial
		begin
			$readmemh("code.txt",im);
		end
//read data in code.txt
	assign	dout = im[addr];
endmodule
```

#### mux2_5

##### 基本描述

5位宽二路选择器 根据选择信号选通不同数据

##### 模块接口

| 接口名 | 方向 |   描述    |
| :----: | :--: | :-------: |
|   a    |  I   | 数据输入a |
|   b    |  I   | 数据输入b |
|   s    |  I   | 选择信号  |
|   y    |  O   | 数据输出  |

##### 功能

根据选通信号`s`选通数据 `s == 0`时选通`a` `s == 1`时选通`b`

##### 代码实现

```verilog
module mux2_5(a,b,s,y);
//choose data by 's' 
	input[4:0]	a,b;
	input		s;
	output[4:0]	y;
//5-bit binary number
	
	reg[4:0]	y;
//reg-type output
	always@(*)
		if(s == 0)
			y <= a;
		else if(s == 1)
			y <= b;
endmodule
```

#### RegFile_PPL

##### 基本描述

32 * 32bit寄存器组 既可向指定寄存器写入数据 也可从指定寄存器中读取数据

##### 模块接口

| 模块名 | 方向 |                      描述                       |
| :----: | :--: | :---------------------------------------------: |
|   op   |  I   | 指令操作码 辅助判断一些对寄存器组较为特殊的指令 |
|   PC   |  I   |                  当前指令地址                   |
| alure  |  I   |                   alu运算结果                   |
|   rs   |  I   |                Wr段rs寄存器编号                 |
|   rt   |  I   |                Wr段rt寄存器编号                 |
|   rd   |  I   |                Wr段rd寄存器编号                 |
| shamt  |  I   |                 移位指令移位数                  |
|  func  |  I   |                R型指令辅助操作码                |
|  data  |  I   |                    输入数据                     |
| RegWr  |  I   |               寄存器组写使能信号                |
| RegDst |  I   |               目标寄存器选择信号                |
|  clk   |  I   |                    时钟信号                     |
| reset  |  I   |                    复位信号                     |
|  rs2   |  I   |                ID段rs寄存器编号                 |
|  rt2   |  I   |                ID段rt寄存器编号                 |
|  rs3   |  I   |          pre_instruction中rs寄存器编号          |
|  rt3   |  I   |          pre_instruction中rt寄存器编号          |
|   ra   |  O   |                  ID段busA输出                   |
|   rb   |  O   |                  ID段busB输出                   |
|  ra2   |  O   |            pre_instruction的busA输出            |
|  rb2   |  O   |            pre_instrcution的busB输出            |

##### 功能

1. `ID`段实现寄存器读 将`rs`和`rt`寄存器的值分别输出到`busA`和`busB`
2. `Wr`段实现寄存器写 将`data`写入指定寄存器中
3. 对`branch`指令的情况 在`ID`段同时读出`pre_instruction`中`rs`和`rt`寄存器中的值并保存供后续使用

##### 代码实现

```verilog
module RegFile_PPL(op,PC,alure,rs,rt,rd,shamt,func,data,RegWr,RegDst,rs2,rt2,ra,rb,rs3,rt3,ra2,rb2,clk,reset);
	input[5:0]	op;
	input[31:2]	PC;
	input[31:0]	alure;
	input[4:0]	rs,rt,rd,shamt;
	input[5:0]	func;
	input[31:0]	data;
	input		RegWr;
	input		RegDst;
	input 		clk;
	input		reset;
	input[4:0]	rs2,rt2;
	input[4:0]	rs3,rt3;
	output[31:0]	ra,rb;
	output[31:0]	ra2,rb2;

	reg[31:0]	rgs[31:0];
	integer		i;
	always@(negedge clk or posedge reset)
		begin
			if(reset == 1)
			begin
				for(i = 0;i < 32;i = i + 1)
					rgs[i] <= 32'b0;
//initial assignment
			end
			if(RegWr)
				case(op)
					6'b100000:
						begin
							rgs[rt] <= data;
							/*if(alure[1:0] == 2'b00)		rgs[rt]<={{24{data[7]}},data[7:0]};
							if(alure[1:0] == 2'b01)		rgs[rt]<={{24{data[15]}},data[15:8]};
							if(alure[1:0] == 2'b10)		rgs[rt]<={{24{data[23]}},data[23:16]};					
							if(alure[1:0] == 2'b11)		rgs[rt]<={{24{data[31]}},data[31:24]};*/
						end
					6'b100100:
						begin
							rgs[rt] <= data;
							/*if(alure[1:0] == 2'b00)		rgs[rt]<={{24'b0},data[7:0]};
							if(alure[1:0] == 2'b01)		rgs[rt]<={{24'b0},data[15:8]};
							if(alure[1:0] == 2'b10)		rgs[rt]<={{24'b0},data[23:16]};					
							if(alure[1:0] == 2'b11)		rgs[rt]<={{24'b0},data[31:24]};*/
						end		
					6'b000011: rgs[31]<={(PC+30'd2),2'b00};//jal
					6'b001111: rgs[rt]<={rd,shamt,func,16'b0};//lui
					default:
						begin
							if(rt == 0 && rd == 5'b11111 && shamt == 0 && func == 6'b001001)
								rgs[31] <= {(PC+30'd2),2'b00};//jalr
							else if(RegDst == 1)	rgs[rd] <= data;
								
							else if(RegDst == 0)	rgs[rt] <= data;
						end 
				endcase
		end

	assign	ra = (rs2!=0)? rgs[rs2] : 0;
	assign	rb = (rt2!=0)? rgs[rt2] : 0;
	assign	ra2 = (rs3!=0)?rgs[rs3] : 0;
	assign	rb2 = (rt3!=0)?rgs[rt3] : 0;
// get data from register
endmodule
```

#### PC_PPL

##### 基本描述

对当前指令地址（PC）进行操作的模块

##### 模块接口

|  接口名  | 方向 |       描述       |
| :------: | :--: | :--------------: |
|   NPC    |  I   |    下指令地址    |
|   rst    |  I   |     复位信号     |
|   clk    |  I   |     时钟信号     |
|    PC    |  O   |   当前指令地址   |
| Load_use |  I   | Load_use冒险信号 |

##### 功能

1. 对`PC`进行复位
2. 无`Load_use`冒险时对`PC`正常赋值
3. 有`Load_use`冒险时阻塞`PC`赋值

##### 代码实现

```verilog
module PC_PPL(NPC,rst,clk,PC,
Load_use);
	input[31:2]	NPC;
	input		rst;
	input 		clk;
	input		Load_use;
	
	output[31:2]	PC;

	reg[31:2]	PC;
	initial
	begin
		PC = 0;
	end
	always @(negedge clk or posedge rst)
		begin
			if(rst == 1)
				PC<=0;
//initial assignment pc <= 13
			else if(!Load_use)
				PC<=NPC;
		end
endmodule
```

#### NPC

##### 基本描述

用来计算下地址的逻辑模块

##### 模块接口

| 接口名 | 方向 |                        描述                        |
| :----: | :--: | :------------------------------------------------: |
|   PC   |  I   |                    当前指令地址                    |
|  NPC   |  O   |                     下指令地址                     |
|  jump  |  I   |                 jump类指令标志信号                 |
| branch |  I   |                branch类指令标志信号                |
|  zero  |  I   |                     0标志信号                      |
|   op   |  I   |                     指令操作码                     |
| target |  I   |                  J型指令target域                   |
| imm16  |  I   |                   I型指令立即数                    |
|  busA  |  I   |                    rs寄存器的值                    |
|   rs   |  I   |                    rs寄存器编号                    |
|   rt   |  I   |                    rt寄存器编号                    |
|   rd   |  I   |                    rd寄存器编号                    |
| shamt  |  I   |                   移位指令移位数                   |
|  func  |  I   |                 R型指令辅助操作码                  |
|  sign  |  O   | 实际跳转标志位 0表示实际发生了跳转 1表示实际未发生 |

##### 功能

1. 根据当前指令操作码计算正确的下地址 并将其赋值给`NPC`
2. 判断跳转指令实际上是否发生了调转 将判断结果赋值给`sign`以供后续使用

##### 代码实现

```verilog
module NPC(PC,NPC,jump,branch,zero,op,target,imm16,busA,rs,rt,rd,shamt,func,
sign,CPR14);
	input[31:2]	PC;
	output[31:2]	NPC;
	input		jump,branch,zero;
	input[5:0]	op;
	input[25:0]	target;
	input[15:0]	imm16;
	input[31:0]	busA;
	input[4:0]	rs,rt,rd,shamt;
	input[5:0]	func;
	input[31:0]	CPR14;

	output reg	sign;

	reg[31:2]	NPC;
	wire[31:2]	B_NPC = {{14{imm16[15]}},imm16[15:0]} + PC - 1; //要减1是因为译码完成传入时已经到了跳转指令的ID段 PC已经 + 1了
//NPC with branch instructions

	wire[31:2]	J_NPC = {PC[31:28],target};
//NPC with jump instructions

	wire[31:2]	N_NPC = PC + 1;
//normal NPC

	reg[31:2]	EXC_ENTER_ADDR;
//jump address of ERET isntruction

	initial
	begin
			NPC = 0;
			sign = 0;
			EXC_ENTER_ADDR = 0;
	end
//initial assignment

	always @(*)
		begin
			case(op)
				6'b000100: //beq
					begin 
						if(zero==1 && branch==1)//jump when two inputs equal
						begin
							NPC <= B_NPC;
							sign <= 0;
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
				6'b000101: //bne
					begin
						if(zero==0 && branch==1)//jump when two inputs not equal
						begin
							NPC <= B_NPC;
							sign <= 0;
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
			 	6'b000001: 
					begin
						if(rt == 1 && branch == 1&& (busA == 0||busA[31] == 0))//bgez - jump when busA >= 0
						begin
							NPC <= B_NPC;
							sign <= 0;
						end
					   	else if(rt == 0 && branch == 1 && busA[31] == 1 && busA != 0)//bltz - jump when busA < 0
						begin
							NPC <= B_NPC;
							sign <= 0;
						end
						else	
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
				6'b000111: //bgtz - jump when busA > 0
					begin
						if(branch == 1 && busA[31] == 0 && busA != 0)
						begin
							NPC <= B_NPC;
							sign <= 0;		
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
				6'b000110: //blez - jump when busA <= 0
					begin
						if(branch == 0 && (busA[31] == 1||busA == 0))
						begin
							NPC <= B_NPC;
							sign <= 0;
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
				6'b000010: //j
					begin
						if(jump == 1)
						begin
							NPC <= J_NPC;
							sign <= 0;
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
				6'b000011: //jal 
					begin
						if(jump == 1)
						begin
							NPC <= J_NPC;
							sign <= 0;
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 1;
						end
					end
				6'b000000: 
					begin
					  	if(rt == 0 && imm16 == 16'b1111100000001001)	
						begin
							NPC <= busA[31:2];//jalr
							sign <= 0;
						end
					  	else if(rt == 0 && imm16 == 16'b0000000000001000)	
						begin
							NPC <= busA[31:2];//jr
							sign <= 0;
						end
						else if(func == 6'b001100)
						begin
							NPC <= EXC_ENTER_ADDR;//ERET
							sign <= 0;
						end
						else	
						begin
							NPC <= N_NPC;
							sign <= 0;
						end
					end
				6'b010000:
					begin
						if(func == 6'b011000)//syscall
						begin
							NPC <= CPR14[31:2];
							sign <= 0;
						end
						else
						begin
							NPC <= N_NPC;
							sign <= 0;
						end
					end
				default: //normal instructions
					begin
						NPC <= N_NPC;
						sign <= 0;
					end
			endcase
		end
endmodule
```

#### IUnit

##### 基本描述

取指令部件

##### 模块接口

|   接口名    | 方向 |     描述     |
| :---------: | :--: | :----------: |
|     PC      |  I   | 当前指令地址 |
|    IF_PC    |  O   |    IF段PC    |
| instruction |  O   |     指令     |

##### 功能

1. 根据`PC`取出当前指令
2. 对`IF_PC`赋为`PC`的值

##### 代码实现

```verilog
`include"im.v"

module IUnit(PC,IF_PC,instruction);
	input[31:2]	PC;
	output[31:2]	IF_PC;
	output[31:0]	instruction;

	im_4k imD(PC[11:2],instruction);
	assign	IF_PC = PC;
endmodule 
```

#### IF_ID

##### 基本描述

`IF_ID`流水段寄存器

##### 模块接口

| 信号名 | 方向 | 描述 |
| :-: | :-: | :-: |
| IF\_PC | I | IF段PC的值 |
| Instruction | I | IF段instruction的值 |
| ID\_PC | O | ID段PC的值 |
| ID\_instruction | O | ID段instruction的值 |
| Jump | I | ID段jump的值 |
| Branch | I | ID段branch的值 |
| op | I | ID段op的值 |
| func | I | ID段func的值 |
| clk | I | 时钟信号 |
| Load_use | I | Load_use冒险信号 |
| sign | I | 跳转指令实际是否发生跳转的标志 |
| ID_instruction | O | ID段指令 |
| pre_instruction | O | 保存的跳转指令的下一条指令 |
| signal | O | 跳转指令实际是否发生跳转的标志 |

##### 功能

1. 作为`IF`和`ID`段的信息中转站
2. 生跳转指令时 将`ID`段指令清0（中止指令）并将下一条指令保存到`pre_instruction`中
3. 发生`load_use`冒险时 阻塞对`ID`段的指令赋值 从而实现插入气泡

##### 代码实现

```verilog
module IF_ID(IF_PC,instruction,ID_PC,ID_instruction,Jump,Branch,op,func,clk,
pre_instruction,sign,signal,
Load_use);
	input[31:2]	IF_PC;
	input[31:0]	instruction;
	input		clk;
	input		Jump;
	input		Branch;
	input		Load_use;
	input		sign;
	input[5:0]	op,func;
		
	output reg[31:2]	ID_PC;
	output reg[31:0]	ID_instruction;
	output reg[31:0]	pre_instruction;
	output reg		signal;
//assignment
	
	initial
	begin
		ID_PC = 30'b0;
		ID_instruction = 32'b0;
		pre_instruction = 32'b0;
		signal = 0;
	end
//initial assignment
		
	always@(negedge clk)
	begin
		if((op == 6'b000000 && func == 6'b001100) || (op == 6'b010000 && func == 6'b011000))
//syscall and ERET
		begin
			ID_instruction <= 32'b0;
			signal <= sign;
		end
		else if(!Load_use && !Jump && !Branch)
//normal instructions
		begin
			ID_PC <= IF_PC;
			ID_instruction <= instruction;
			signal <= sign;
		end
		else if(!Load_use && (Jump || Branch))
//jump and branch instructions with a delay slot 
		begin
			// ID_instruction <= instruction;			
			ID_instruction <= 32'b0;//this is for code without a delay slot
			pre_instruction <= instruction;
			signal <= sign;
		end
	end
endmodule
```

#### ID

##### 基本描述

`ID`流水段

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| ID\_PC | I | ID段PC的值 |
| ID\_op | O | ID段op的值 |
| ID\_rs | O | ID段rs的值 |
| ID\_rt | O | ID段rt的值 |
| ID\_rd | O | ID段rd的值 |
| ID\_shamt | O | ID段shamt的值 |
| ID\_func | O | ID段func的值 |
| ID\_imm16 | O | ID段imm16的值 |
| ID\_target | O | ID段target的值 |
| ID\_busA | O | ID段busA的值 |
| ID\_busB | O | ID段busB的值 |
| ID\_RegDst | O | ID段RegDst的值 |
| ID\_RegWr | O | ID段RegWr的值 |
| ID\_ALUSrc | O | ID段ALUSrc的值 |
| ID\_MemWr | O | ID段MemWr的值 |
| ID\_MemtoReg | O | ID段MemtoReg的值 |
| ID\_Branch | O | ID段Branch的值 |
| ID\_Jump | O | ID段Jump的值 |
| ID\_ExtOp | O | ID段ExtOp的值 |
| ID\_ALUctr | O | ID段ALUctr的值 |
| ID\_instruction | I | ID段instruction的值 |
| NPC | O | 当前NPC的值 |
| Wr\_op | I | Wr段op的值 |
| Wr\_PC | I | Wr段PC的值 |
| Wr\_alure | I | Wr段alu结果的值 |
| Wr\_rs | I | Wr段rs的值 |
| Wr\_rt | I | Wr段rt的值 |
| Wr\_rd | I | Wr段rd的值 |
| Wr\_shamt | I | Wr段shamt的值 |
| Wr\_func | I | Wr段func的值 |
| Wr\_busW | I | Wr段busW的值 |
| Wr\_RegWr | I | Wr段RegWr的值 |
| Wr\_RegDst | I | Wr段RegDst的值 |
| alure | I | EX段alu的结果 |
| Mem\_alure | I | Mem段的alu的结果 |
| Mem\_dout | I | Mem段dout的结果 |
| Mem\_MemtoReg | I | Mem段MemtoReg的结果 |
| ALUSrcC | I | 数据冒险检测ALUSrcC的值 |
| ALUSrcD | I | 数据冒险检测ALUSrcD的值 |
| PC | I | 当前PC的值 |
| sign | O | 判断branch指令是否跳转的标志 |
| pre\_instruction | I | 跳转指令的下一条指令 |
| E | O | pre\_instruction的busA数据冒险检测结果 |
| F | O | pre\_instruction的busB数据冒险检测结果 |
| ALUSrcE | I | 数据冒险检测ALUSrcE的值 |
| ALUSrcF | I | 数据冒险检测ALUSrcF的值 |
| Wr\_busA | I | Wr段busA的值 |
| Wr\_busB | I | Wr段busB的值 |
| EX\_busA | I | EX段busA的值 |
| Mem\_busA | I | Mem段busA的值 |
| A | O | ID段busA数据冒险检测结果 |
| B | O | ID段busB数据冒险检测结果 |
| EX\_busB | I | EX段busB的值 |
| Mem\_busB | I | Mem段的busB的值 |
| clk | I | 时钟信号 |
| rst | I | 复位信号 |

##### 功能

1. 利用`ctrl`模块对当前指令进行译码
2. 接收`Wr`段的各信号进行寄存器写
3. 直接在`ID`段求出下地址`NPC`
4. 根据数据冒险的情况选择出`EX`段`ALU`两个输入端口的数值

##### 代码实现

```verilog
`include"ctrl.v"
`include"RegFile_PPL.v"
`include"MULTFile.v"
`include"CPRFile.v"
`include"NPC.v"

module ID(ID_PC,ID_op,ID_rs,ID_rt,ID_rd,ID_shamt,ID_func,ID_imm16,ID_target,ID_busA,ID_busB,ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,
ID_Branch,ID_Jump,ID_ExtOp,ID_ALUctr,ID_instruction,NPC,
Wr_op,Wr_PC,Wr_alure,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_busW,Wr_RegWr,Wr_RegDst,
alure,Mem_alure,Mem_dout,Mem_MemtoReg,
ALUSrcC,ALUSrcD,
PC,
sign,
pre_instruction,E,F,
ALUSrcE,ALUSrcF,
Wr_MULT_result,Wr_busA,Wr_busB,
G,H,EX_MULT_result,EX_busA,Mem_MULT_result,Mem_busA,
ALUSrcG,ALUSrcH,ALUSrcK,ALUSrcL,
A,B,K,
EX_busB,Mem_busB,
clk,reset);

	input clk,reset;
	input[31:2]	ID_PC;
	input[31:0]	ID_instruction;
	input[5:0]	Wr_op;
	input[31:2]	Wr_PC;
	input[31:0]	Wr_alure;
	input[4:0]	Wr_rs,Wr_rt,Wr_rd,Wr_shamt;
	input[5:0]	Wr_func;
	input[31:0]	Wr_busW;
	input	Wr_RegWr,Wr_RegDst;

	input[1:0]	ALUSrcC,ALUSrcD;
	input[1:0]	ALUSrcE,ALUSrcF;
	input[31:0]	alure,Mem_alure,Mem_dout;
	input	Mem_MemtoReg;

	input[31:2]	PC;
	input[31:0]	pre_instruction;
	input[63:0]	Wr_MULT_result,EX_MULT_result,Mem_MULT_result;
	input[31:0]	Wr_busA,EX_busA,Mem_busA;
	input[2:0]	ALUSrcG,ALUSrcH;
	input[1:0]	ALUSrcK,ALUSrcL;
	input[31:0]	EX_busB,Mem_busB,Wr_busB;

	output[5:0]	ID_op;
	output[4:0]	ID_rs,ID_rt,ID_rd,ID_shamt;
	output[5:0]	ID_func;
	output[15:0]	ID_imm16;
	output[25:0]	ID_target;
	output[31:0]	ID_busA,ID_busB;
	output		ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,ID_Branch,ID_Jump;
	output[1:0]	ID_ExtOp;
	output[4:0]	ID_ALUctr;
	output[31:2]	NPC;
	output		sign;
	output[31:0]	K;

	output[31:0]	E,F;
	output[31:0]	G,H;
	wire[31:0]	ID_hi_num,ID_lo_num;

	wire[31:0]	pre_busA,pre_busB;
	wire[31:2]	FormerPC;
	wire		ID_zero;
	wire[31:0]	cs_num;
	assign	FormerPC = ID_PC - 1;//Is this correct? check it later

	assign	ID_op = ID_instruction[31:26];
	assign	ID_rs = ID_instruction[25:21];
	assign	ID_rt = ID_instruction[20:16];
	assign	ID_rd = ID_instruction[15:11];
	assign	ID_shamt = ID_instruction[10:6];
	assign	ID_func = ID_instruction[5:0];
	assign	ID_imm16 = ID_instruction[15:0];
	assign	ID_target = ID_instruction[25:0];

	wire[31:2]	Wr_FormerPC;
	assign		Wr_FormerPC = Wr_PC - 1;

	wire[31:0]	CPR14;

	ctrl ctrlPPL(ID_op,ID_rs,ID_rt,ID_rd,ID_shamt,ID_func,ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,ID_ExtOp,ID_ALUctr,ID_Branch,ID_Jump);
	RegFile_PPL REGPPL(Wr_op,Wr_FormerPC,Wr_alure,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_busW,Wr_RegWr,Wr_RegDst,ID_rs,ID_rt,ID_busA,ID_busB,pre_instruction[25:21],pre_instruction[20:16],pre_busA,pre_busB,clk,reset);
	MULTFile MFPPL(Wr_op,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_MULT_result,ID_hi_num,ID_lo_num,Wr_busA,clk);
	CPRFile CPRPPL(Wr_op,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,ID_rd,cs_num,Wr_busB,Wr_FormerPC,CPR14,clk);
//some operations with data in other segments, mainly the write register operation

	output[31:0]	A,B;

	assign	A = (ALUSrcC == 2'b00)? ID_busA :
		(ALUSrcC == 2'b01)? alure :
		(ALUSrcC == 2'b10 && Mem_MemtoReg == 0)? Mem_alure :
		(ALUSrcC == 2'b10 && Mem_MemtoReg == 1)? Mem_dout : 
		(ALUSrcC == 2'b11)? Wr_busW : 0;
	assign	B = (ALUSrcD == 2'b00)? ID_busB :
		(ALUSrcD == 2'b01)? alure :
		(ALUSrcD == 2'b10 && Mem_MemtoReg == 0)? Mem_alure :
		(ALUSrcD == 2'b10 && Mem_MemtoReg == 1)? Mem_dout : 
		(ALUSrcD == 2'b11)? Wr_busW : 0; 
//Pre_data_hazard

	assign	E = (ALUSrcE == 2'b00)? pre_busA :
		(ALUSrcE == 2'b10)? Wr_busW : 0;

	assign	F = (ALUSrcF == 2'b00)? pre_busB :
		(ALUSrcF == 2'b10)? Wr_busW : 0;
//branch_data_hazard

	assign	G = (ALUSrcG == 3'b000)? ID_lo_num :
		(ALUSrcG == 3'b001)? EX_busA :
		(ALUSrcG == 3'b010)? EX_MULT_result[31:0] :
		(ALUSrcG == 3'b011)? Mem_busA : 
		(ALUSrcG == 3'b100)? Mem_MULT_result[31:0] : 
		(ALUSrcG == 3'b101)? Wr_busA : 
		(ALUSrcG == 3'b110)? Wr_MULT_result[31:0] :0;

	assign	H = (ALUSrcH == 3'b000)? ID_hi_num :
		(ALUSrcH == 3'b001)? EX_busA :
		(ALUSrcH == 3'b010)? EX_MULT_result[63:32] :
		(ALUSrcH == 3'b011)? Mem_busA : 
		(ALUSrcH == 3'b100)? Mem_MULT_result[63:32] : 
		(ALUSrcH == 3'b101)? Wr_busA : 
		(ALUSrcH == 3'b110)? Wr_MULT_result[63:32] :0;
//MULT_data_hazard

	assign	K = (ALUSrcK == 2'b00)? cs_num :
		(ALUSrcK == 2'b01)? EX_busB :
		(ALUSrcK == 2'b10)? Mem_busB :
		(ALUSrcK == 2'b11)? Wr_busB :0;
//CPR_data_hazard
	assign	ID_zero = (A == B)?1:0;

	wire[31:0]	L;
	assign	L = (ALUSrcL == 2'b00)? CPR14 :
		(ALUSrcL == 2'b01)? EX_busB :
		(ALUSrcL == 2'b10)? Mem_busB :
		(ALUSrcL == 2'b11)? Wr_busB :0;
//ERET_data_hazard

	NPC NPCPPL(PC,NPC,ID_Jump,ID_Branch,ID_zero,ID_op,ID_target,ID_imm16,A,ID_rs,ID_rt,ID_rd,ID_shamt,ID_func,sign,L);
//NPC calculation

endmodule
```

#### ID_EX

##### 基本描述

`ID_EX`流水段寄存器

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| ID\_PC | I | ID段PC的值 |
| ID\_op | I | ID段op的值 |
| ID\_rs | I | ID段rs的值 |
| ID\_rt | I | ID段rt的值 |
| ID\_rd | I | ID段rd的值 |
| ID\_shamt | I | ID段shamt的值 |
| ID\_func | I | ID段func的值 |
| ID\_imm16 | I | ID的imm16的值 |
| ID\_target | I | ID段target的值 |
| ID\_busA | I | ID段busA的值 |
| ID\_busB | I | ID段busB的值 |
| ID\_RegDst | I | ID段RegDst的值 |
| ID\_RegWr | I | ID段RegWr的值 |
| ID\_ALUSrc | I | ID段ALUSrc的值 |
| ID\_MemWr | I | ID段MemWr的值 |
| ID\_MemtoReg | I | ID段MemtoReg的值 |
| ID\_Branch | I | ID段Branch的值 |
| ID\_Jump | I | ID段Jump的值 |
| ID\_ExtOp | I | ID段ExtOp的值 |
| ID\_ALUctr | I | ID段ALUctr的值 |
| clk | I | 时钟信号 |
| EX\_PC | O | EX段PC的值 |
| EX\_op | O | EX段op的值 |
| EX\_rs | O | EX段rs的值 |
| EX\_rt | O | EX段rt的值 |
| EX\_rd | O | EX段rd的值 |
| EX\_shamt | O | EX段shamt的值 |
| EX\_func | O | EX段func的值 |
| EX\_imm16 | O | EX段imm16的值 |
| EX\_target | O | EX段target的值 |
| EX\_busA | O | EX段busA的值 |
| EX\_busB | O | EX段busB的值 |
| EX\_RegDst | O | EX段RegDst的值 |
| EX\_RegWr | O | EX段RegWr的值 |
| EX\_ALUSrc | O | EX段ALUSrc的值 |
| EX\_MemWr | O | EX段MemWr的值 |
| EX\_MemtoReg | O | EX段MemtoReg的值 |
| EX\_Branch | O | EX段Branch的值 |
| EX\_Jump | O | EX段Jump的值 |
| EX\_ExtOp | O | EX段ExtOp的值 |
| EX\_ALUctr | O | EX段ALUctr的值 |
| Load\_use | I | Load\_use冒险判断 |
| signal | I | 跳转指令跳转判断 |
| pre\_instruction | I | 跳转指令的下一条指令 |
| E | I | Pre\_instruction的busA数据冒险检测结果 |
| F | I | Pre\_instruction的busB数据冒险检测结果 |
| A | I | ID段busA数据冒险检测结果 |
| B | I | ID段 busB数据冒险检测结果 |

##### 功能

1. 存储所有需从`ID`段传递到`EX`段的控制信号与数据
2. 发生`Load_use`冒险时 将传递给`EX`段的所有控制信号和数据清零 从而实现插入气泡
3. 发生跳转指令预测错误时 将预先保存的`pre_instruction`的各控制信号与数据赋值给`EX`段 从而实现纠错

##### 代码实现

```verilog
module ID_EX(ID_PC,ID_op,ID_rs,ID_rt,ID_rd,ID_shamt,ID_func,ID_imm16,ID_target,ID_busA,ID_busB,ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,ID_Branch,ID_Jump,ID_ExtOp,ID_ALUctr,
G,H,K,
clk,
EX_PC,EX_op,EX_rs,EX_rt,EX_rd,EX_shamt,EX_func,EX_imm16,EX_target,EX_busA,EX_busB,EX_RegDst,EX_RegWr,EX_ALUSrc,EX_MemWr,EX_MemtoReg,EX_Branch,EX_Jump,EX_ExtOp,EX_ALUctr,
EX_hi_num,EX_lo_num,EX_cs_num,
Load_use,
signal,pre_instruction,E,F,
A,B);
//ID_EX segment register

	input[31:2]	ID_PC;
	input[5:0]	ID_op;
	input[4:0]	ID_rs,ID_rt,ID_rd,ID_shamt;
	input[5:0]	ID_func;
	input[15:0]	ID_imm16;
	input[25:0]	ID_target;
	input[31:0]	ID_busA,ID_busB;
	input		ID_RegDst,ID_RegWr,ID_ALUSrc,ID_MemWr,ID_MemtoReg,ID_Branch,ID_Jump;
	input[1:0]	ID_ExtOp;
	input[4:0]	ID_ALUctr;
	input		clk;		
	input		Load_use;
	input		signal;
	input[31:0]	pre_instruction;
	input[31:0]	E,F;
	input[31:0]	G,H;
	input[31:0]	A,B;
	input[31:0]	K;

	output reg[31:2]	EX_PC;
	output reg[5:0]		EX_op;
	output reg[4:0]		EX_rs,EX_rt,EX_rd,EX_shamt;
	output reg[5:0]		EX_func;
	output reg[15:0]	EX_imm16;
	output reg[25:0]	EX_target;
	output reg[31:0]	EX_busA,EX_busB;
	output reg		EX_RegDst,EX_RegWr,EX_ALUSrc,EX_MemWr,EX_MemtoReg,EX_Branch,EX_Jump;
	output reg[1:0]		EX_ExtOp;
	output reg[4:0]		EX_ALUctr;
	output reg[31:0]	EX_hi_num,EX_lo_num;
	output reg[31:0]	EX_cs_num;

	wire[5:0]	pre_op;
	wire[4:0]	pre_rs,pre_rt,pre_rd,pre_shamt;
	wire[5:0]	pre_func;
	wire[15:0]	pre_imm16;
	wire[25:0]	pre_target;
	wire		pre_RegDst,pre_RegWr,pre_ALUSrc,pre_MemWr,pre_MemtoReg,pre_Branch,pre_Jump;
	wire[1:0]	pre_ExtOp;
	wire[4:0]	pre_ALUctr;
//pre_instruction is the instruction which is deleted when branch instruction appears.
//but this only works in test code without delay slot
	assign	pre_op = pre_instruction[31:26];
	assign	pre_rs = pre_instruction[25:21];
	assign	pre_rt = pre_instruction[20:16];
	assign	pre_rd = pre_instruction[15:11];
	assign	pre_shamt = pre_instruction[10:6];
	assign	pre_func = pre_instruction[5:0];
	assign	pre_imm16 = pre_instruction[15:0];
	assign	pre_target = pre_instruction[25:0];

		ctrl CPPL(pre_op,pre_rs,pre_rt,pre_rd,pre_shamt,pre_func,pre_RegDst,pre_RegWr,pre_ALUSrc,pre_MemWr,pre_MemtoReg,pre_ExtOp,pre_ALUctr,pre_Branch,pre_Jump);
//get relevant information of pre_instruction by ctrl

	initial
	begin
		EX_PC = 0;
		EX_op = 0;
		EX_rs = 0;
		EX_rt = 0;
		EX_rd = 0;
		EX_shamt = 0;
		EX_func = 0;
		EX_imm16 = 0;
		EX_target = 0;
		EX_busA = 0;
		EX_busB = 0;
		EX_RegDst = 0;
		EX_RegWr = 0;
		EX_ALUSrc = 0;
		EX_MemWr = 0;
		EX_MemtoReg = 0;
		EX_Branch = 0;
		EX_Jump = 0;
		EX_ExtOp = 0;
		EX_ALUctr = 0;
		EX_hi_num = 0;
		EX_lo_num = 0;
		EX_cs_num = 0;
		
	end
//initial assignment

	always@(negedge clk)
	begin
		if(Load_use == 1)
		begin
		EX_PC <= 0;
		EX_op <= 0;
		EX_rs <= 0;
		EX_rt <= 0;
		EX_rd <= 0;
		EX_shamt <= 0;
		EX_func <= 0;
		EX_imm16 <= 0;
		EX_target <= 0;
		EX_busA <= 0;
		EX_busB <= 0;
		EX_RegDst <= 0;
		EX_RegWr <= 0;
		EX_ALUSrc <= 0;
		EX_MemWr <= 0;
		EX_MemtoReg <= 0;
		EX_Branch <= 0;
		EX_Jump <= 0;
		EX_ExtOp <= 0;
		EX_ALUctr <= 0;
		EX_hi_num <= 0;
		EX_lo_num <= 0;
		EX_cs_num <= 0;
		end

		else if(signal == 1) //跳转指令没有发生有效跳转
		begin	
		EX_PC <= ID_PC + 1;//预测错误 此时EX段应修正执行之前保存的pre_instruction 其PC应为之前没变的ID_PC + 1
		EX_op <= pre_op;
		EX_rs <= pre_rs;
		EX_rt <= pre_rt;
		EX_rd <= pre_rd;
		EX_shamt <= pre_shamt;
		EX_func <= pre_func;
		EX_imm16 <= pre_imm16;
		EX_target <= pre_target;
		EX_busA <= E;
		EX_busB <= F;
		EX_RegDst <= pre_RegDst;
		EX_RegWr <= pre_RegWr;
		EX_ALUSrc <= pre_ALUSrc;
		EX_MemWr <= pre_MemWr;
		EX_MemtoReg <= pre_MemtoReg;
		EX_Branch <= pre_Branch;
		EX_Jump <= pre_Jump;
		EX_ExtOp <= pre_ExtOp;
		EX_ALUctr <= pre_ALUctr;
		EX_hi_num <= H;
		EX_lo_num <= G;
		EX_cs_num <= K;
		end
//pre_instruction assignment

		else
		begin
		EX_PC <= ID_PC;
		EX_op <= ID_op;
		EX_rs <= ID_rs;
		EX_rt <= ID_rt;
		EX_rd <= ID_rd;
		EX_shamt <= ID_shamt;
		EX_func <= ID_func;
		EX_imm16 <= ID_imm16;
		EX_target <= ID_target;
		EX_busA <= A;
		EX_busB <= B;
		EX_RegDst <= ID_RegDst;
		EX_RegWr <= ID_RegWr;
		EX_ALUSrc <= ID_ALUSrc;
		EX_MemWr <= ID_MemWr;
		EX_MemtoReg <= ID_MemtoReg;
		EX_Branch <= ID_Branch;
		EX_Jump <= ID_Jump;
		EX_ExtOp <= ID_ExtOp;
		EX_ALUctr <= ID_ALUctr;
		EX_hi_num <= H;
		EX_lo_num <= G;
		EX_cs_num <= K;
		end
// normal assignment with no Load_use and no branch instruction without really jump		
	end

endmodule
```

#### EX

##### 基本描述

`EX`流水段

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| EX\_PC | I | EX段PC的值 |
| EX\_op | I | EX段op的值 |
| EX\_rs | I | EX段rs的值 |
| EX\_rt | I | EX段rt的值 |
| EX\_rd | I | EX段rd的值 |
| EX\_shamt | I | EX段shamt的值 |
| EX\_func | I | EX段func的值 |
| EX\_imm16 | I | EX段imme16的值 |
| EX\_target | I | EX段target的值 |
| EX\_busA | I | EX段busA的值 |
| EX\_busB | I | EX段busB的值 |
| EX\_RegDst | I | EX段RegDst的值 |
| EX\_RegWr | I | EX段RegWr的值 |
| EX\_ALUSrc | I | EX段ALUSrc的值 |
| EX\_MemWr | I | EX段MemW的值 |
| EX\_MemtoReg | I | EX段MemtoReg的值 |
| EX\_Branch | I | EX段Branch的值 |
| EX\_Jump | I | EX段Jump的值 |
| EX\_ExtOp | I | EX段ExtOp的值 |
| EX\_ALUctr | I | EX段ALUctr的值 |
| alure | O | EX段alu的结果 |
| EX\_Reg | O | EX段根据EX\_RegDst信号选择寄存器的编号 |
| clk | I | 时钟信号 |
| Mem\_alure | I | Mem段alu的结果 |
| Wr\_busW | I | Wr段busW的值 |
| EX\_MemRead | O | EX段MemRead的值，判断是否为lw指令 |

##### 功能

1. 进行`ALU`运算
2. 用`RegDst`进行目标写寄存器的选择

##### 代码实现

```verilog
`include"extender.v"
`include"alu.v"
`include"MULT.v"
`include"mux2_5.v"

module EX(EX_PC,EX_op,EX_rs,EX_rt,EX_rd,EX_shamt,EX_func,EX_imm16,EX_target,EX_busA,EX_busB,
EX_RegDst,EX_RegWr,EX_ALUSrc,EX_MemWr,EX_MemtoReg,EX_Branch,EX_Jump,EX_ExtOp,EX_ALUctr,
alure,EX_Reg,clk,
Mem_alure,Wr_busW,
EX_MemRead,
EX_MULT_result,
EX_hi_num,EX_lo_num,
EX_cs_num);
	input[31:2]	EX_PC;
	input[5:0]	EX_op;
	input[4:0]	EX_rs,EX_rt,EX_rd,EX_shamt;
	input[5:0]	EX_func;
	input[15:0]	EX_imm16;
	input[25:0]	EX_target;
	input[31:0]	EX_busA,EX_busB;
	input		EX_RegDst,EX_RegWr,EX_ALUSrc,EX_MemWr,EX_MemtoReg,EX_Branch,EX_Jump;
	input[1:0]	EX_ExtOp;
	input[4:0]	EX_ALUctr;

	input		clk;

	//input[1:0]	ALUSrcA,ALUSrcB;
	input[31:0]	Mem_alure,Wr_busW;
	input[31:0]	EX_hi_num,EX_lo_num;
	input[31:0]	EX_cs_num;

	output[31:0]	alure;//alu result
	output[4:0]	EX_Reg;//rt or rd

	output	EX_MemRead;
	output[63:0]	EX_MULT_result;	

	assign	EX_MemRead = (EX_op == 6'b100011)? 1:0;

	wire[31:0]	EX_imm32;
	wire[31:0]	B;
	wire[31:0]	G,H;
	wire		zero;

	extender extM(EX_imm16,EX_ExtOp,EX_imm32);//need
	/*assign A = (ALUSrcA == 2'b00)? EX_busA :
		(ALUSrcA == 2'b01)? Mem_alure :
		(ALUSrcA == 2'b10)? Wr_busW : 0;
	assign B = (ALUSrcB == 2'b00)? EX_busB :
		(ALUSrcB == 2'b01)? Mem_alure :
		(ALUSrcB == 2'b10)? Wr_busW :
		(ALUSrcB == 2'b11)? EX_imm32 : 0;
	assign C = (ALUSrcB == 2'b00)? EX_busB :
		(ALUSrcB == 2'b01)? Mem_alure :
		(ALUSrcB == 2'b10)? Wr_busW :
		(ALUSrcB == 2'b11)? EX_busB : 0;*/

	assign	B = (EX_ALUSrc == 1)? EX_imm32 : EX_busB;
	alu AM(EX_ALUctr,EX_busA,B,EX_imm32,EX_shamt,alure,zero,EX_lo_num,EX_hi_num,EX_cs_num);
//alu calculation
	MULT MU(EX_op,EX_busA,EX_busB,EX_rd,EX_shamt,EX_func,EX_MULT_result);
//MULT calculation
	mux2_5 mux(EX_rt,EX_rd,EX_RegDst,EX_Reg);
//choose data

endmodule
```

#### EX_Mem

##### 基本描述

`EX_Mem`流水段寄存器

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| EX\_op | I | EX段op的值 |
| EX\_Reg | I | EX段Reg的值 |
| EX\_MemWr | I | EX段MemWr的值 |
| EX\_MemtoReg | I | EX段MemtoReg的值 |
| EX\_PC | I | EX段PC的值 |
| EX\_rs | I | EX段rs的值 |
| EX\_rt | I | EX段rt的值 |
| EX\_rd | I | EX段rd的值 |
| EX\_shamt | I | EX段shamt的值 |
| EX\_func | I | EX段func的值 |
| EX\_RegDst | I | EX段RegDst的值 |
| EX\_busA | I | EX段busA的值 |
| EX\_busB | I | EX段busB的值 |
| alure | I | EX段alu的结果 |
| clk | I | 时钟信号 |
| Mem\_op | O | Mem段op的值 |
| Mem\_Reg | O | Mem段Reg的值 |
| Mem\_RegWr | O | Mem段RegWr的值 |
| Mem\_MemWr | O | Mem段MemWr的值 |
| Mem\_MemtoReg | O | Mem段MemtoReg的值 |
| Mem\_alure | O | Mem段ALU的结果 |
| Mem\_PC | O | Mem段PC的值 |
| Mem\_rs | O | Mem段rs的值 |
| Mem\_rt | O | Mem段rt的值 |
| Mem\_rd | O | Mem段rd的值 |
| Mem\_shamt | O | Mem段shamt的值 |
| Mem\_func | O | Mem段func的值 |
| Mem\_RegDst | O | Mem段RegDst的值 |
| Mem\_busA | O | Mem段busA的值 |
| Mem\_busB | O | Mem段busB的值 |

##### 功能

将`EX`段的各控制信号与数据传递给`Mem`段

##### 代码实现

```verilog
module EX_Mem(EX_op,EX_Reg,EX_RegWr,EX_MemWr,EX_MemtoReg,EX_PC,EX_rs,EX_rt,EX_rd,EX_shamt,EX_func,EX_RegDst,EX_busA,EX_busB,alure,clk,
Mem_op,Mem_Reg,Mem_RegWr,Mem_MemWr,Mem_MemtoReg,Mem_alure,Mem_PC,Mem_rs,Mem_rt,Mem_rd,Mem_shamt,Mem_func,Mem_RegDst,Mem_busA,Mem_busB,
EX_MULT_result,Mem_MULT_result);
//EX_Mem segment register
	input[5:0]	EX_op;
	input[4:0]	EX_Reg;
	input		EX_RegWr,EX_MemWr,EX_MemtoReg;
	input[31:0]	alure;
	input		clk;

	input[31:2]	EX_PC;
	input[4:0]	EX_rs,EX_rt,EX_rd,EX_shamt;
	input[5:0]	EX_func;
	input		EX_RegDst;
	input[31:0]	EX_busA,EX_busB;

	input[63:0]	EX_MULT_result;

	output reg[5:0]	Mem_op;
	output reg[4:0]	Mem_Reg;
	output reg		Mem_RegWr,Mem_MemWr,Mem_MemtoReg;
	output reg[31:0]	Mem_alure;
	output reg[31:2]	Mem_PC;
	output reg[4:0]	Mem_rs,Mem_rt,Mem_rd,Mem_shamt;
	output reg[5:0]	Mem_func;
	output reg	Mem_RegDst;
	output reg[31:0]	Mem_busA,Mem_busB;
	output reg[63:0]	Mem_MULT_result;
//assignment

	initial
	begin
		Mem_op = 0;
		Mem_Reg = 0;
		Mem_RegWr = 0;
		Mem_MemWr = 0;
		Mem_MemtoReg = 0;
		Mem_alure = 0;
		Mem_PC = 0;
		Mem_rs = 0;
		Mem_rt = 0;
		Mem_rd = 0;
		Mem_shamt = 0;
		Mem_func = 0;
		Mem_RegDst = 0;
		Mem_busA = 0;
		Mem_busB = 0;
		Mem_MULT_result = 0;
	end
//initial assignment

	always@(negedge clk)
	begin
		Mem_op <= EX_op;
		Mem_Reg <= EX_Reg;
		Mem_RegWr <= EX_RegWr;
		Mem_MemWr <= EX_MemWr;
		Mem_MemtoReg <= EX_MemtoReg;
		Mem_alure <= alure;
		Mem_PC <= EX_PC;
		Mem_rs <= EX_rs;
		Mem_rt <= EX_rt;
		Mem_rd <= EX_rd;
		Mem_shamt <= EX_shamt;
		Mem_func <= EX_func;
		Mem_RegDst <= EX_RegDst;
		Mem_busA <= EX_busA;
		Mem_busB <= EX_busB;
		Mem_MULT_result <= EX_MULT_result;
	end
//normal assignment
endmodule
```

#### Mem

#####基本描述

`Mem`流水段

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| Mem\_op | I | Mem段op的值 |
| Mem\_Reg | I | Mem段Reg的值 |
| Mem\_busB | I | Mem段busB的值 |
| Mem\_RegWr | I | Mem段RegWr的值 |
| Mem\_MemWr | I | Mem段MemWr的值 |
| Mem\_MemtoReg | I | Mem段MemtoReg的值 |
| Mem\_alure | I | Mem段alu的值 |
| clk | I | 时钟信号 |
| Mem\_dout | O | Mem段读取的主存结果 |

##### 功能

1. 对`store`型指令 在该阶段将数据存入数据存储器中
2. 对`load`型指令 在该阶段从数据存储器中读取数据

##### 代码实现

```verilog
`include"dm.v"

module Mem(Mem_op,Mem_Reg,Mem_busB,Mem_RegWr,Mem_MemWr,Mem_MemtoReg,Mem_alure,clk,Mem_dout);
	input[5:0]	Mem_op;
	input[4:0]	Mem_Reg;
	input[31:0]	Mem_busB;
	input 		Mem_RegWr,Mem_MemWr,Mem_MemtoReg;
	input[31:0]	Mem_alure;
	input		clk;

	output[31:0]	Mem_dout;

	dm_4k dmT(Mem_op,Mem_alure,Mem_busB,Mem_dout,clk,Mem_MemWr);//data memory invoking
endmodule
```

#### Mem_Wr

##### 基本描述

`Mem_Wr`流水段寄存器

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| Mem\_op | I | Mem段op的值 |
| Mem\_Reg | I | Mem段Reg的值 |
| Mem\_RegWr | I | Mem段RegWr的值 |
| Mem\_MemtoReg | I | Mem段MemtoReg的值 |
| Mem\_alure | I | Mem段alu的结果 |
| Mem\_dout | I | Mem段主存的输出结果 |
| Mem\_PC | I | Mem段PC的值 |
| Mem\_rs | I | Mem段rs的值 |
| Mem\_rt | I | Mem段rt的值 |
| Mem\_rd | I | Mem段rd的值 |
| Mem\_shamt | I | Mem段shamt的值 |
| Mem\_func | I | Mem段func的值 |
| Mem\_RegDst | I | Mem段RegDst的值 |
| Mem\_busA | I | Mem段busA的值 |
| Mem\_busB | I | Mem段busB的值 |
| clk | I | 时钟信号 |
| Wr\_op | O | Wr段op的值 |
| Wr\_Reg | O | Wr段Reg的值 |
| Wr\_RegWr | O | Wr段RegWr的值 |
| Wr\_MemtoReg | O | Wr段MemtoReg的值 |
| Wr\_alure | O | Wr段alu的结果 |
| Wr\_dout | O | Wr段主存的输出结果 |
| Wr\_PC | O | Wr段PC的值 |
| Wr\_rs | O | Wr段rs的值 |
| Wr\_rt | O | Wr段rt的值 |
| Wr\_rd | O | Wr段rd的值 |
| Wr\_shamt | O | Wr段shamt的值 |
| Wr\_func | O | Wr段func的值 |
| Wr\_RegDst | O | Wr段RegDst的值 |
| Wr\_busA | O | Wr段busA的值 |
| Wr\_busB | O | Wr段busB的值 |

##### 功能

将`Mem`段的各控制信号和数据传给`Wr`段

##### 代码实现

```verilog
module Mem_Wr(Mem_op,Mem_Reg,Mem_RegWr,Mem_MemtoReg,Mem_alure,Mem_dout,Mem_PC,Mem_rs,Mem_rt,Mem_rd,Mem_shamt,Mem_func,Mem_RegDst,Mem_busA,Mem_busB,clk,
Wr_op,Wr_Reg,Wr_RegWr,Wr_MemtoReg,Wr_alure,Wr_dout,Wr_PC,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_RegDst,Wr_busA,Wr_busB,
Mem_MULT_result,Wr_MULT_result);
//Mem_Wr segement register
	input[5:0]	Mem_op;
	input[4:0]	Mem_Reg;
	input 		Mem_RegWr,Mem_MemtoReg;
	input[31:0]	Mem_alure;
	input[31:0]	Mem_dout;
	input		clk;

	input[31:2]	Mem_PC;
	input[4:0]	Mem_rs,Mem_rt,Mem_rd,Mem_shamt;
	input[5:0]	Mem_func;
	input	Mem_RegDst;
	input[31:0]	Mem_busA,Mem_busB;
	input[63:0]	Mem_MULT_result;

	output reg[5:0]	Wr_op;
	output reg[4:0]	Wr_Reg;
	output reg	Wr_RegWr,Wr_MemtoReg;
	output reg[31:0]	Wr_alure;
	output reg[31:0]	Wr_dout;

	output reg[31:2]	Wr_PC;
	output reg[4:0]	Wr_rs,Wr_rt,Wr_rd,Wr_shamt;
	output reg[5:0]	Wr_func;
	output reg	Wr_RegDst;
	output reg[31:0]	Wr_busA,Wr_busB;
	output reg[63:0]	Wr_MULT_result;
	
	initial 
	begin
		Wr_op = 0;
		Wr_Reg = 0;
		Wr_RegWr = 0;
		Wr_MemtoReg = 0;
		Wr_alure = 0;
		Wr_dout = 0;
		Wr_PC = 0;
		Wr_rs = 0;
		Wr_rt = 0;
		Wr_rd = 0;
		Wr_shamt = 0;
		Wr_func = 0;
		Wr_RegDst = 0;
		Wr_busA = 0;
		Wr_busB = 0;
		Wr_MULT_result = 0;
	end
//initial assignment

	always@(negedge clk)
	begin
		Wr_op <= Mem_op;
		Wr_Reg <= Mem_Reg;
		Wr_RegWr <= Mem_RegWr;
		Wr_MemtoReg <= Mem_MemtoReg;
		Wr_alure <= Mem_alure;
		Wr_dout <= Mem_dout;
		Wr_PC <= Mem_PC;
		Wr_rs <= Mem_rs;
		Wr_rt <= Mem_rt;
		Wr_rd <= Mem_rd;
		Wr_shamt <= Mem_shamt;
		Wr_func <= Mem_func;
		Wr_RegDst <= Mem_RegDst;
		Wr_busA <= Mem_busA;
		Wr_busB <= Mem_busB;
		Wr_MULT_result <= Mem_MULT_result;
	end
//normal assignment
endmodule
```

#### Wr

##### 基本描述

`Wr`流水段

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| Wr\_op | I | Wr段op的值 |
| Wr\_Reg | I | Wr段Reg的值 |
| Wr\_MemtoReg | I | Wr段MemtoReg的值 |
| Wr\_alure | I | Wr段alu的结果 |
| Wr\_dout | I | Wr段主存的输出结果 |
| Wr\_PC | I | Wr段PC的值 |
| Wr\_rs | I | Wr段rs的值 |
| Wr\_rt | I | Wr段rt的值 |
| Wr\_rd | I | Wr段rd的值 |
| Wr\_shamt | I | Wr段shamt的值 |
| Wr\_func | I | Wr段func的值 |
| Wr\_RegDst | I | Wr段RegDst的值 |
| Wr\_busA | I | Wr段busA的值 |
| Wr\_busB | I | Wr段busB的值 |
| clk | I | 时钟信号 |
| Wr\_busW | O | Wr段存入寄存器的值 |

##### 功能

在该阶段根据`op`和`MemtoReg`信号选择出正确的写入数据 并同控制信号一起传入设置在`ID`段的寄存器组 实现写回操作

##### 代码实现

```verilog
module Wr(Wr_op,Wr_Reg,Wr_RegWr,Wr_MemtoReg,Wr_alure,Wr_dout,Wr_PC,Wr_rs,Wr_rt,Wr_rd,Wr_shamt,Wr_func,Wr_RegDst,Wr_busA,Wr_busB,clk,Wr_busW);//change
	input[5:0]	Wr_op;
	input[4:0]	Wr_Reg;
	input		Wr_RegWr,Wr_MemtoReg;
	input[31:0]	Wr_alure;
	input[31:0]	Wr_dout;
	input[31:2]	Wr_PC;
	input[4:0]	Wr_rs,Wr_rd,Wr_rt,Wr_shamt;
	input[5:0]	Wr_func;
	input		Wr_RegDst;
	input[31:0]	Wr_busA,Wr_busB;

	input clk;
	
	output reg[31:0]	Wr_busW;
//statement

	always@(*)
	begin
		if(Wr_op == 6'b100000)
		begin
			Wr_busW<={{24{Wr_dout[7]}},Wr_dout[7:0]};
		end
//this is for instruction 'lb'-load byte

		else if(Wr_op == 6'b100100)
		begin
			Wr_busW<={{24'b0},Wr_dout[7:0]};
		end
//this is for instruction 'lbu'-load byte unsigned

		else
		begin
			if(Wr_MemtoReg == 0)	Wr_busW <= Wr_alure;
			else	Wr_busW <= Wr_dout;
			//mux2_32 muxW(Wr_alure,Wr_dout,Wr_MemtoReg,Wr_busW);
		end
//choose data to assign Wr_busW by Wr_MemtoReg
	end
endmodule
```

### 2. 控制器

#### conrtol

##### 基本描述

控制器模块 接收指令的`op`和`func`域信号 对指令译码 产生该指令对应的控制信号

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| op | I | 指令操作码 |
| rs | I | rs寄存器地址 |
| rt | I | rt寄存器地址 |
| rd | I | rd寄存器地址 |
| shamt | I | 偏移量 |
| func | I | 指令5-0位 |
| RegDst | O | rt,rd寄存器选择控制信号 |
| RegWr | O | 寄存器写控制信号 |
| ALUSrc | O | ALU数据来源控制信号 |
| MemWr | O | 数据内存写控制信号 |
| MemtoReg | O | 数据内存数据写入寄存器控制信号 |
| ExtOp | O | 立即数扩展控制信号 |
| ALUctr | O | ALU控制信号 |
| Branch | O | 条件跳转指令控制信号 |
| Jump | O | J型指令控制信号 |

##### 功能

1. 当`op`不为0 即指令不为R型指令时 根据`op`对指令进行译码 将各信号输送给对应的控制信号
2. 当`op`的值为0 即指令为R型指令时 根据`func`对指令进行译码 将各信号书送给对应的控制信号

##### 代码实现

```verilog
module ctrl(op,rs,rt,rd,shamt,func,RegDst,RegWr,ALUSrc,MemWr,MemtoReg,ExtOp,ALUctr,Branch,Jump);
	input[5:0] 	op;
	input[4:0]	rs,rt,rd,shamt;
	input[5:0]	func;
	output		RegDst;
	output		RegWr;
	output		ALUSrc;
	output		MemWr;
	output		MemtoReg;
	output[1:0]	ExtOp;
	output[4:0]	ALUctr;
	output		Branch;
	output		Jump;		

	reg[13:0]	controls;

	assign{RegDst,RegWr,ALUSrc,MemWr,MemtoReg,ExtOp,ALUctr,Branch,Jump} = controls;

	always@(*)
		case(op)
			6'b000000:
				begin
					case(func)
						6'b100001: controls <= 14'b11000000000000;//addu
						6'b100011: controls <= 14'b11000000000100;//subu
						6'b101010: controls <= 14'b11000000001000;//slt
						6'b100100: controls <= 14'b11000000001100;//and
						6'b100111: controls <= 14'b11000000010000;//nor
						6'b100101: controls <= 14'b11000000010100;//or
						6'b100110: controls <= 14'b11000000011000;//xor
						6'b000000: controls <= 14'b11000000011100;//sll
						6'b000010: controls <= 14'b11000000100000;//srl
						6'b101011: controls <= 14'b11000000100100;//sltu
						6'b001001: controls <= 14'b11000000000001;//jalr
						6'b001000: controls <= 14'b10000000000001;//jr
						6'b000100: controls <= 14'b11000000110000;//sllv
						6'b000011: controls <= 14'b11000000110100;//sra
						6'b000111: controls <= 14'b11000000111000;//srav
						6'b000110: controls <= 14'b11000000111100;//srlv
						6'b011000: controls <= 14'b00000000000000;//mult
						6'b010010: controls <= 14'b11000001011100;//mflo
						6'b010000: controls <= 14'b11000001100000;//mfhi
						6'b010011: controls <= 14'b00000000000000;//mtlo
						6'b010001: controls <= 14'b00000000000000;//mthi
						6'b001100: controls <= 14'b00000000000000;//syscall
					endcase
				end
			6'b001001: controls <= 14'b01100011000000;//addiu
			6'b000100: controls <= 14'b00000000000110;//beq
			6'b000101: controls <= 14'b00000000000110;//bne
			6'b100011: controls <= 14'b01101011000000;//lw
			6'b101011: controls <= 14'b00110011000000;//sw
			6'b001111: controls <= 14'b01100101011000;//lui
			6'b001010: controls <= 14'b01100011000100;//slti
			6'b001011: controls <= 14'b01100011001000;//sltiu
			6'b000001: controls <= 14'b00000000000010;//bgez,bltz 
				
			6'b000111: controls <= 14'b00000000000010;//bgtz
			6'b000110: controls <= 14'b00000000000010;//blez
			6'b100000: controls <= 14'b01101011000000;//lb
			6'b100100: controls <= 14'b01101011000000;//lbu
			6'b101000: controls <= 14'b00110011000000;//sb
			6'b001100: controls <= 14'b01100001001100;//andi
			6'b001101: controls <= 14'b01100001010000;//ori
			6'b001110: controls <= 14'b01100001010100;//xori

			
			6'b000010: controls <= 14'b00000000000001;//j
			6'b000011: controls <= 14'b01000000000001;//jal

			6'b010000:
			begin
				case(rs)
				5'b00000: controls <= 14'b01000001100100;//mfc0
				5'b00100: controls <= 14'b00000000000000;//mtc0
				5'b10000: controls <= 14'b00000000000000;//eret
				endcase
			end

			default : controls <= 14'b00000000000000;
		endcase
//assign 'controls' according to instructions
endmodule 
```

##### （附）控制信号真值表

![image-20230629100345128](/Users/plotnickslope/Library/Application Support/typora-user-images/image-20230629100345128.png)

###3. 冒险处理

***冒险分析：***

*数据冒险*

分为`Pre_Data_Hazard，Branch_Data_Hazard`这两个模块处理，其基本思想一致：处理从寄存器中读数存在的延迟问题。在ID段进行检测，处理在EX段，Mem段，Wr段可能出现的寄存器数据修改问题。取到的寄存器数应为最近一次修改的值。最后将对应冒险标记变量进行冒险记录并输出

*结构冒险*

1. 将指令存储器与数据存储器分成两个独立的模块

2. 同一时间段寄存器的读与写相冲突，依然使用转发技术，将写操作中ALU已经产生的结果送到读操作ALU的输入端。

![image-20230701212751570](/Users/plotnickslope/Library/Application Support/typora-user-images/image-20230701212751570.png)

> 数据冒险与结构冒险处理

*Load_use冒险*

主要靠`Load_use`信号进行判断，在`Load_use`模块中进行，若出现`Load_use`冒险，则`Load_use`信号为1，进行如下操作：

1. 将`ID_EX`流水段的控制信号清零
2. 保持`IF_ID`流水段的指令不变
3. 保持`PC`的值不变

通过以上三个操作实现一个周期的阻塞 从而可以通过前面的数据冒险处理方式对`Load_use`冒险进行处理

![image-20230701213220067](/Users/plotnickslope/Library/Application Support/typora-user-images/image-20230701213220067.png)

> `Load_use`数据冒险

*控制冒险*

采用静态预测，始终预测指令满足跳转。在IF_ID段寄存器中进行判断和处理，若为分支指令或跳转指令，则将IF段的指令记录为pre_instruction，并将ID段指令赋值为0以实现对下一条指令的清零，PC不变，若跳转（预测成功），则正常执行，若不跳转（预测失败），则ID_EX段寄存器中，将之前保存的pre_instruction对应的控制信号与数据赋给EX段的控制信号与数据，实现纠错。

#### Pre_Data_Hazard

#####基本描述

处理数据冒险的模块

#####模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| Mem\_RegWr | I | Mem段RegWr的值 |
| Mem\_Reg | I | Mem段Reg的值 |
| ID\_rs | I | ID段rs的值 |
| ID\_rt | I | ID段rt的值 |
| EX\_RegWr | I | EX段RegWr的值 |
| EX\_Reg | I | EX段Reg的值 |
| Wr\_RegWr | I | Wr段RegWr的值 |
| Wr\_Reg | I | Wr段Reg的值 |
| ALUSrcC | O | 数据冒险选择信号 |
| ALUSrcD | O | 数据冒险选择信号 |

##### 功能

判断相隔1条 2条或3条的数据冒险 并根据不同情况对选择信号`ALUSrcC`和`ALUSrcD`进行赋值 具体的对应关系可通过代码及注释查阅

##### 代码实现

```verilog
module Pre_Data_Hazard(Mem_RegWr,Mem_Reg,ID_rs,ID_rt,EX_RegWr,EX_Reg,Wr_RegWr,Wr_Reg,ALUSrcC,ALUSrcD);
	input	Mem_RegWr,EX_RegWr,Wr_RegWr;
	input[4:0]	Mem_Reg,EX_Reg,Wr_Reg,ID_rs,ID_rt;
//parameters which is needed in this module	

	wire	C1C,C1D,C2C,C2D,C3C,C3D;
//intermediate variables	

	assign	C1C = EX_RegWr && (EX_Reg != 0) && (EX_Reg == ID_rs);
	assign	C1D = EX_RegWr && (EX_Reg != 0) && (EX_Reg == ID_rt);
	assign	C2C = Mem_RegWr && (Mem_Reg != 0) && ((EX_Reg != ID_rs)||(EX_Reg == ID_rs && EX_RegWr == 0)) && (Mem_Reg == ID_rs);
	assign	C2D = Mem_RegWr && (Mem_Reg != 0) && ((EX_Reg != ID_rt)||(EX_Reg == ID_rt && EX_RegWr == 0)) && (Mem_Reg == ID_rt);
	assign	C3C = Wr_RegWr && (Wr_Reg != 0) && ((EX_Reg != ID_rs)||(EX_Reg == ID_rs && EX_RegWr == 0)) && ((Mem_Reg != ID_rs)||(Mem_Reg == ID_rs && Mem_RegWr == 0)) && (Wr_Reg == ID_rs);
	assign	C3D = Wr_RegWr && (Wr_Reg != 0) && ((EX_Reg != ID_rt)||(EX_Reg == ID_rt && EX_RegWr == 0)) && ((Mem_Reg != ID_rt)||(Mem_Reg == ID_rt && Mem_RegWr == 0)) && (Wr_Reg == ID_rt); 
//definitions

	output reg[1:0]	ALUSrcC,ALUSrcD;
//reg-type output

	initial
	begin
		ALUSrcC = 0;
		ALUSrcD = 0;
	end
//initial assignment

	always@(C1C or C2C or C3C)
	begin
		if(C1C == 1)	ALUSrcC <= 2'b01;//RS EX-segment data hazard
		else if(C2C == 1)	ALUSrcC <= 2'b10;//RS Mem-segment data hazard
		else if(C3C == 1)	ALUSrcC <= 2'b11;//RS Wr-segment data hazard
		else	ALUSrcC <= 2'b00;//no data hazard
	end

	always@(C1D or C2D or C3D)
	begin
		if(C1D == 1)	ALUSrcD <= 2'b01;//RT EX-segment data hazard
		else if(C2D == 1)	ALUSrcD <= 2'b10;//RT Mem-segment data hazard
		else if(C3D == 1)	ALUSrcD <= 2'b11;//RT Wr-segment data hazard
		else	ALUSrcD <= 2'b00;//no data hazard
	end

endmodule	
```

#### branch_Data_Hazard

##### 基本描述

出现分支指令时 对预先保存的`pre_instruction`进行数据冒险判断的模块

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| Wr\_RegWr | I | Wr段RegWr的值 |
| Wr\_Reg | I | Wr段Reg的值 |
| Pre\_rs | I | Preinstruction的rs的值 |
| Pre\_rt | I | Preinstruction的rt的值 |
| Mem\_RegWr | I | Mem段RegWr的值 |
| Mem\_Reg | I | Mem段Reg的值 |
| ALUSrcE | O | 数据冒险检测信号 |
| ALUSrcF | O | 数据冒险检测信号 |

##### 功能

判断`pre_instruction`的数据冒险 并根据不同情况对选择信号`ALUSrcC`和`ALUSrcD`进行赋值 具体的对应关系可通过代码及注释查阅

##### 代码实现

```verilog
module branch_Data_Hazard(Wr_RegWr,Wr_Reg,pre_rs,pre_rt,Mem_RegWr,Mem_Reg,ALUSrcE,ALUSrcF);
	input	Wr_RegWr,Mem_RegWr;
	input[4:0]	Wr_Reg,Mem_Reg,pre_rs,pre_rt;

	wire	C2E,C2F;

	assign	C2E = Wr_RegWr && (Wr_Reg!=0) && ((Mem_Reg != pre_rs) || (Mem_Reg == pre_rs && Mem_RegWr == 0)) && (Wr_Reg == pre_rs);
	assign	C2F = Wr_RegWr && (Wr_Reg!=0) && ((Mem_Reg != pre_rt) || (Mem_Reg == pre_rt && Mem_RegWr == 0)) && (Wr_Reg == pre_rt);

	output reg[1:0]	ALUSrcE,ALUSrcF;

	initial
	begin
		ALUSrcE = 0;
		ALUSrcF = 0;
	end

	always@(C2E)
	begin
		if(C2E == 1)	ALUSrcE <= 2'b10;
		else		ALUSrcE <= 2'b00;
	end

	always@(C2F)
	begin
		if(C2F == 1)	ALUSrcF <= 2'b10;
		else		ALUSrcF <= 2'b00;
	end

endmodule
```

#### Load_use

##### 基本描述

判断`Load_use`数据冒险的模块

##### 模块接口

| 接口名 | 方向 | 描述 |
| :-: | :-: | :-: |
| EX\_MemRead | I | EX段检测是否为lw型指令 |
| EX\_rt | I | EX段rt的值 |
| ID\_rs | I | ID段rs的值 |
| ID\_rt | I | ID段rt的值 |
| Load\_use | O | Load\_use冒险检测信号 |

##### 功能

检测`Load_use`数据冒险 产生判断信号以供后续使用

#####代码实现

```verilog
module Load_use(EX_MemRead,EX_rt,ID_rs,ID_rt,Load_use);
//Load_use hazard judge
	input	EX_MemRead;
	input[4:0]	EX_rt,ID_rs,ID_rt;
	output reg	Load_use;
	wire	C;
	
	assign	C = EX_MemRead && ((EX_rt == ID_rs) || (EX_rt == ID_rt));

	initial
	begin
		Load_use = 0;
	end

	always@(C)
	begin
		Load_use = C;
	end

endmodule
```

## 三. 测试代码及方法

### 1. 环境配置

由于我的电脑是MacOS系统 无法安装modelsim进行仿真 故根据网上共享的配置方案 用vscode + 插件 + gtkwave搭配的方法对代码进行仿真与运行 具体来说 执行如下：

+ 在vscode中安装如下插件

  ![截屏2023-06-30 08.19.29](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-06-30 08.19.29.png)

  > 安装的插件列表

+ 通过Homebrew 在终端中安装如下软件

  ![截屏2023-06-30 08.21.54](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-06-30 08.21.54.png)

  > 通过Homebrew安装的软件列表

上述配置完成后 可以在vscode中对`Verilog`代码进行编译运行 并使用gtkwave或vscode对波形进行仿真

### 2. 测试代码

来自老师发送的测试代码文件 `《36条指令-对应的汇编代码+指令字等-红色字新加说明》`

将测试代码的以十六进制存储在`code.txt`中效果如下：

![截屏2023-06-30 08.29.57](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-06-30 08.29.57.png)

> 测试代码（十六进制）

### 3. 测试结果

由于`gtkwave`虽能仿真波形 但无法监测到模块内部定义的变量信号（如寄存器组中每个寄存器的值 数据存储器中每块内存的值）所以采用每一周期将寄存器值与数据存储器中的数据输出到`out.txt`文件的形式对数据进行侦测 从而判断指令执行的正确性

+ 数据结果（存储在`out.txt`中）

  ![截屏2023-07-01 22.00.54](/Users/plotnickslope/Desktop/截屏/截屏2023-07-01 22.00.54.png)

  > 此处展示的是最后一周期所有代码执行完毕之后的结果

+ 波形仿真结果（存储在`pipeline_cpu_wave.vcd`中）

  ![截屏2023-07-01 22.03.08](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-07-01 22.03.08.png)

  >  由于数据结果另做处理 此处只展示控制信号的仿真结果
  
  ==请老师检查时注意 由于数据存储器`dm`中的各数据没有初始化为0 所以在查看与数据存储器相关的波形时可能会出现红线 但并不是错误！==

## 四. 总结与展望

在完成单周期CPU的编写后，我曾一度以为流水线CPU设计非常的简单，可是现实却击垮了我。相对于流水线CPU而言，单周期CPU就是简简单单的几个模块组合在一起，而流水线所要考虑的并行性、冒险性才是更为折磨的考验。仅仅掌握书本上流水线思想、流水线数据通路、流水线冒险判断与处理的知识，对于编写流水线CPU是完全不够的，需要经过很多次的实践才能深入理解流水线的执行。于卷考而言，通过流水线CPU的编写，使得我对卷考知识的掌握更加透彻，这也节省了我后期不少时间。

在编写相关代码时，我是先进行36条的编写并调试。而36条的调试过程是最痛苦的时间段。当时对流水线相关知识其实还是半知不解，就是按照书上和PPT上的思路搬过来，没有什么自己的思考和理解，而在调试的过程中，我深深地体会到了这样的不可行性。主要体现在我对错误发生源的寻找困难以及修改错误的编写困难。三天时间，一直都蹲在电脑前，波形不对——寻找错误——修改错误，一直这样循环往复，但在后期对冒险处理的理解更加深刻之后，难度减少了很多。我觉得最困难的地方应该是控制冒险的处理了，但这也是我看到自己思考的闪光点的一部分。我使用的方法是插入空指令，始终预测其会跳转，但这就会影响不跳转的情况，所以我选择将IF段的instruction存储在pre_instruction中，并且添加signal判断分支指令是否跳转，若不跳转，则选择将pre_instruction中的数据存储到EX阶段。这个的调试用了相当长的时间，但最终成功了。

在扩展45条指令时，遇到的困难要比之前少很多，虽然多了HI,LO寄存器和协处理器，但我们接触到的形式其实和之前写的RegFile寄存器十分相似，以近似的方法进行编写即可，处理数据冒险的方式也基本相同。有了36条作为基础，45条的编写和调试都较快，但最终由于复习时间不够与ddl的问题，没能在截止时间前完成剩余9条的调试。

在这次的课程设计中，我通过对流水线CPU编写，从CPU的角度理解了计算机的组成，对计算机的体系结构有了一个初步的了解。感谢那个迎难而上、勇于实践的自己，更感谢身边优秀、贴心的朋友、老师。